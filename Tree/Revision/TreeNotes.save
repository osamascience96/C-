Note:- Each Subtree are disjoints from each other subtree.

Degree of Node: Any Node that contains n number of nodes as its desendants. This could be the degree of any Node i-e Root or SubNode(that could also be Subtree)

Degree of Tree: A degree of the tree is that node in the tree that has the highest degree.

Leaf/Terminal Node: The Node with the degree 0.

Level: Each Node is assigned a level number. Each descendant node has the (l+1) level from its ancestors nodes, where l is the level of the node(ancestor).

Generation: Nodes that belongs to the same level belongs to the same generation.

Height/Depth: The longest branch in the tree OR The branch with most number of reached levels in the tree is the Height/Depth of the tree.

Edge: Line drawn between any 2 nodes in the tree OR any line connecting two nodes in the tree is the edge.
      Note: The direction of the edge any tree is from top to bottom only.

Path: Sequence of consecutive edges.

Branch: Path ending on a leaf node.

Note: Branch can contain many paths, a branch can also be refered to as a path.

Binary Tree:- A tree that has its 2 desendants in every node it it is the binary tree.
Binary Tree can be represented in both arrays and linkedlist using the pointer structure.
	Node Structure:
		Data
	Left Ptr    Right Ptr



There are 3 types of traversals in the tree:

	1) PreOrder Traversal
	2) InOrder Traversal
	3) PostOrder Traversal

In Preorder Traversal, we process the root, leftNode, rightNode.
In InOrder Traversal, we process the leftNode, root, rightNode.
In PostOrder Traversal, we process the leftNode, rightNode and root.


Level Order Traversal:
We do level order traversal by processing all the nodes on each level from top to bottom approach by using the queue datastructure, that can be used to store the nodes of the current level node(s) that process the root first, then after that process the leftnode and rightnode

Binary Search Tree:
	In BST, the nodes are traversed and inserted according to one rules:
		If the number to be inserted or find, is smaller than the root node, then go to the left subtree
		If the number to be inserted or find, is greater then the root node, then go to the right subtree
	
	The finding element is used while finding, inserting and deleting operations in the BST.
	

	While deleting the nodes in the binary tree, there are 3 cases:
		*) The node to be deleted can be a leaf
		*) The node to be deleted can be a linear branch, having only one desendant.
		*) The node to be deleted can be non-linear branch, have multiple desendants.

	
	When we delete a node that has 2 desendants to be confirmed, the following solutions.
		1) Non-Practical Solution:
			*)Traverse to left side of the root node
			*)Find the maximum node on that branch
			*)shift the data on to the root node
			*)Delete the Node that was found maximum on that branch
		2) Practical Solution:
			Either works on 2 practical solutions
			*) Fuck(Delete) the Node and all its branches(subtrees)	
			*) Return the null pointer if this shit(Node with 2 desendants) happens.
	

Adelson-Velsky and Landis Tree(AVL Tree):
	

